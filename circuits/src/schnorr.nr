// Schnorr Signature Verification
// Verifies: s * G == R + H(R || pk || m) * pk

use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};
use poseidon::poseidon::bn254;

// Grumpkin generator G0 (from Barretenberg's pedersenCommit generators)
// This is the point 1 * G0 from pedersen_commitment([1, 0], 0)
global G_X: Field = 0x083e7911d835097629f0067531fc15cafd79a89beecb39903f69572c636f4a5a;
global G_Y: Field = 0x1a7f5efaad7f315c25a918f30cc8d7333fccab7ad7c90f14de81bcc528f9935d;

/// Verify a Schnorr signature
/// 
/// # Arguments
/// * `pk_x`, `pk_y` - Public key point
/// * `message` - Message hash (single field element)
/// * `r_x`, `r_y` - R point of signature
/// * `s_lo`, `s_hi` - s scalar split into 128-bit limbs
/// 
/// # Returns
/// true if signature is valid
pub fn verify(
    pk_x: Field,
    pk_y: Field,
    message: Field,
    r_x: Field,
    r_y: Field,
    s_lo: Field,
    s_hi: Field
) -> bool {
    // Verify signature logic
    // Compute challenge: e = H(R || pk || m)
    let e = bn254::hash_5([r_x, r_y, pk_x, pk_y, message]);
    
    // Split e into 128-bit limbs using decomposition
    // e = e_lo + e_hi * 2^128
    let e_bytes = e.to_le_bytes::<32>();
    
    // e_lo = bytes 0..16 (little-endian)
    let mut e_lo: Field = 0;
    let mut multiplier: Field = 1;
    for i in 0..16 {
        e_lo += (e_bytes[i] as Field) * multiplier;
        multiplier *= 256;
    }
    
    // e_hi = bytes 16..32 (little-endian)
    let mut e_hi: Field = 0;
    multiplier = 1;
    for i in 16..32 {
        e_hi += (e_bytes[i] as Field) * multiplier;
        multiplier *= 256;
    }
    
    // Compute LHS: s * G
    let g_point = EmbeddedCurvePoint { x: G_X, y: G_Y, is_infinite: false };
    let s_scalar = EmbeddedCurveScalar { lo: s_lo, hi: s_hi };
    let lhs = multi_scalar_mul([g_point], [s_scalar]);
    
    // Compute RHS: R + e * pk
    let r_point = EmbeddedCurvePoint { x: r_x, y: r_y, is_infinite: false };
    let pk_point = EmbeddedCurvePoint { x: pk_x, y: pk_y, is_infinite: false };
    let e_scalar = EmbeddedCurveScalar { lo: e_lo, hi: e_hi };
    let one_scalar = EmbeddedCurveScalar { lo: 1, hi: 0 };
    
    // R + e * pk using multi_scalar_mul
    let rhs = multi_scalar_mul([r_point, pk_point], [one_scalar, e_scalar]);
    
    // Check equality
    (lhs.x == rhs.x) & (lhs.y == rhs.y)
}

#[test]
fn test_schnorr_placeholder() {
    // TODO: Add test with known test vectors from TypeScript implementation
    // This ensures Noir and TypeScript produce matching signatures
    assert(true);
}

#[test]
fn test_schnorr_regression() {
    // Regression test with known working values (verified against JS implementation)
    // Ensures Poseidon chaining and curve arithmetic remain consistent.
    
    // Keypair
    let pk_x: Field = 0x1bd2ca043010eba0fa5e958f0562792b2861e231c2fd59adf48f26b506a12e0b;
    let pk_y: Field = 0x21f7816e0233e455de2696cc40d5d51c5df34561740d84e17bc360b1aac892fb;
    
    // Message hash (Poseidon2 -> msg)
    let message: Field = 0x2d08784ef1a8e6c8f5f2b6342b1844829c4ed53a58694fc1c915fb7901ec941a;
    
    // Nonce R (generated by JS)
    let r_x: Field = 0x2f6f37f2784b7544ccb4ecde2fad5dec1dfc16556b34d51b2f0e0d7fecf281ba;
    let r_y: Field = 0x06e1f78fb1a6682205a20de90a07d33213521835c10bfadcb61c4358256e34e9;
    
    // Signature s: 0x713575f9d673ed53a66b6143ec6a71139e17e296295c1c75f0b9be389f7ff22
    // Split into 128-bit limbs
    let s_lo: Field = 0x39e17e296295c1c75f0b9be389f7ff22;
    let s_hi: Field = 0x713575f9d673ed53a66b6143ec6a711;
    
    // Expected challenge e (computed by JS)
    let expected_e: Field = 0x04229d52256c2322da0fb46b3800d36ff03796caf77d77fb0e8153c7a60808e1;
    
    // Compute challenge: e = H(R || pk || m)
    let e = bn254::hash_5([r_x, r_y, pk_x, pk_y, message]);
    
    assert(e == expected_e, "e mismatch - Poseidon hash incompatibility??");
    
    // Verify signature logic
    let valid = verify(pk_x, pk_y, message, r_x, r_y, s_lo, s_hi);
    assert(valid, "Signature verification failed");
}


