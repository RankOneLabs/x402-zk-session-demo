# Schnorr Signature Verification Debug Report

## Issue Summary

The Noir circuit fails to verify Schnorr signatures generated by TypeScript, even though all individual cryptographic components appear to match when tested in isolation.

**Error:** `Failed assertion: Invalid signature` during `nbt prove x402_zk_session`

## Architecture

### Signature Scheme
Standard Schnorr on Grumpkin curve (BN254's embedded curve):
- **Sign:** Given secret key `sk`, message `m`, random nonce `k`:
  1. Compute `R = k * G` (nonce point)
  2. Compute `pk = sk * G` (public key)
  3. Compute challenge `e = Poseidon5(R.x, R.y, pk.x, pk.y, m)`
  4. Compute `s = k + e * sk (mod curve_order)`
  5. Signature is `(R, s)`

- **Verify:** Given `pk`, `m`, signature `(R, s)`:
  1. Compute `e = Poseidon5(R.x, R.y, pk.x, pk.y, m)`
  2. Check `s * G == R + e * pk`

### Implementation
- **TypeScript:** Uses `@aztec/bb.js` for Grumpkin operations via `pedersenCommit([scalar, 0], 0) = scalar * G0`
- **Noir:** Uses `std::embedded_curve_ops::multi_scalar_mul` with `EmbeddedCurveScalar { lo, hi }` for 256-bit scalars

## What Works ✅

### 1. Generator Point Matches
```
TypeScript bb.pedersenCommit([1, 0], 0):
  x: 0x083e7911d835097629f0067531fc15cafd79a89beecb39903f69572c636f4a5a
  y: 0x1a7f5efaad7f315c25a918f30cc8d7333fccab7ad7c90f14de81bcc528f9935d

Noir G_X/G_Y: Same values ✅
```

### 2. Scalar Multiplication Matches (2*G test)
```
TypeScript: pedersenCommit([2, 0], 0)
  x: 21257496462400913801282840561021446049249742519529950649510548656246698707241
  y: 9311206937097351457745531264432686767848437768817720608527154146862405004551

Noir: multi_scalar_mul([G], [{lo: 2, hi: 0}])
  Same values ✅
```

### 3. Poseidon Hash Matches
```
TypeScript poseidon5([R.x, R.y, pk.x, pk.y, msg]):
  15667321770285706851567860439889119158791036584861713155547976953546420802083

Noir bn254::hash_5([r_x, r_y, pk_x, pk_y, message]):
  Same value ✅ (confirmed via test_poseidon5)
```

### 4. Poseidon7 for Message Hash
```
TypeScript poseidon7([service_id, tier, max_pres, issued, expires, commit_x, commit_y]):
  5218754217353592738684666472458211292743397235479628375008864193561994863584

Noir bn254::hash_7(same inputs):
  Same value ✅ (confirmed via test_poseidon7)
```

### 5. Limb Splitting (e to e_lo/e_hi)
```
e = 15667321770285706851567860439889119158791036584861713155547976953546420802083

TypeScript: e & ((1n << 128n) - 1n), e >> 128n
Noir: to_le_bytes then reconstruct

Both produce:
  e_lo: 0x40cfb483c9e539b5fd4a82a72f045223
  e_hi: 0x22a363cec05d8242c1c119f3f86767f0 ✅
```

### 6. s * G Matches
```
s = 14883391024981159033933441784953366061265370585836195932990556703736606005989

TypeScript: pedersenCommit([s, 0], 0)
  x: 0x1e14cc162c15b8c2587fa7b585b48d12486c56568b10a8718951fd4861915aff
  y: 0x242e6e152b6f137f941dbbb1d228e3f63f486069ee9077043577cf6aaa164860

Noir: multi_scalar_mul([G], [s_scalar])
  Same values ✅
```

### 7. Point Addition via multi_scalar_mul
```
Test: (k + sk) * G == k*G + sk*G (where k, sk are small values)

Noir multi_scalar_mul([R, pk], [1, 1]) correctly equals (k+sk)*G ✅
```

## What Fails ❌

### The Actual Verification
```
LHS (s * G):
  x: 0x1e14cc162c15b8c2587fa7b585b48d12486c56568b10a8718951fd4861915aff
  y: 0x242e6e152b6f137f941dbbb1d228e3f63f486069ee9077043577cf6aaa164860

RHS (R + e * pk):
  x: 0x1dce8b9335c96a98150b6b237f24ac8819f18f51efa42d830b0ff643de777698
  y: 0x286b123f51f078dce0bebbb0a72ed4b53d6aa621cd309835ec2b9b0419517d20

These do NOT match! ❌
```

### e * pk Mismatch
```
TypeScript: e * pk computed as (e * sk) * G
  x: 0x192268ddcec58c7eb3353f9b1cb84f798fe89534f5b139b50aa2406838ddaf8a
  y: 0x0e1380e113a5fbee7dd3855aa5dabb1af647d482d401877649f65d46baf283e3

Noir: multi_scalar_mul([pk], [e_scalar])
  x: 0x2ba91251ff38fe33d4b4294ad73d722fef7f8c9e8a24116ca541b7ff96d8e29c
  y: 0x06b2af477b494fff79e51e45215454af2ada81033b8d8c461ca60dfd7f409869

MISMATCH ❌
```

## Root Cause Hypothesis

The issue appears to be in how `multi_scalar_mul` handles scalar multiplication with an **arbitrary base point** (pk) vs the **generator** (G).

### Key Observation:
- `multi_scalar_mul([G], [scalar])` produces results matching TypeScript
- `multi_scalar_mul([pk], [e_scalar])` produces DIFFERENT results

### Possible Causes:

1. **Different scalar interpretation:** When multiplying an arbitrary point, `multi_scalar_mul` might interpret the `EmbeddedCurveScalar` differently than when using the generator.

2. **Point encoding issue:** The pk point might be encoded/decoded differently when passed to `multi_scalar_mul` vs when it was originally computed.

3. **Scalar field vs base field confusion:** Grumpkin's scalar field is BN254's base field (and vice versa). There might be field confusion when doing `e * pk` where `e` is a scalar and `pk` is a point.

4. **multi_scalar_mul implementation detail:** The function might use different algorithms for generator multiplication vs arbitrary point multiplication, leading to subtle differences.

## Test Values Used

```
sk = 12345678901234567890
k = 98765432109876543210
msg = 555666777888999

pk = sk * G:
  x: 4487995459841908226541024527283132709619697693159278929978762006984097362577
  y: 8571660945555118922124892307203162141912312929543889646077435926509389365396

R = k * G:
  x: 17603465354240130424494153796389390227299484978922401063153607343617333448555
  y: 1463905919835087874385344536865589815360476156147949623884647266543722265912

e = H(R, pk, msg):
  15667321770285706851567860439889119158791036584861713155547976953546420802083

s = k + e * sk (mod p):
  14883391024981159033933441784953366061265370585836195932990556703736606005989

s_lo: 292863635587060291173365476840527928037
s_hi: 43738355177361219542240589404787882217
```

## Files Modified

- `circuits/src/schnorr.nr` - Schnorr verification with debug tests
- `circuits/src/test_generator.nr` - Component tests (all pass)
- `noir-build-tools/lib/testdata/primitives.mjs` - TypeScript crypto primitives

## Next Steps to Investigate

1. **Check if pk reconstruction matches:** Verify that when we pass `pk_x, pk_y` to the circuit and reconstruct the point, it's the same point.

2. **Test scalar * arbitrary_point directly:** Create a minimal test with known values where we can verify `scalar * point` for a non-generator point.

3. **Check bb.js for point scalar mul:** See if bb.js has a direct `scalarMul(point, scalar)` function we can use to verify.

4. **Inspect multi_scalar_mul source:** Look at the Noir stdlib implementation to understand how it handles arbitrary base points.

5. **Alternative approach:** Instead of computing `e` inside the circuit, pass `e` as a public input and verify `e == H(R, pk, msg)`. This would isolate whether the issue is in the hash or the point multiplication.

## Environment

- Noir: v1.0.0-beta.18
- bb.js: @aztec/bb.js
- poseidon: noir-lang/poseidon v0.2.3
- poseidon-lite: npm (confirmed compatible with noir-lang/poseidon via their oracle_server.ts)

## Final Resolution (2026-01-30)

### The Actual Root Cause
The mismatch was **NOT** in the elliptic curve arithmetic or `multi_scalar_mul`.
The issue was in the **Poseidon Hash calculation** for the message hash `msg`.

- **Noir**: `bn254::hash_7([...])`
- **TypeScript**: `poseidonHash7` (implemented using `poseidonSponge` from `poseidon-lite`)

The sponge construction used by `poseidon-lite` for inputs > 6 did not align with the implementation expected by Noir's `poseidon` library for `hash_7`. This caused the circuit to verify a signature against a different message hash than the one signed by the JS code.

### The Solution: Chained Hashing
We standardized the hashing strategy to use deterministic chaining of smaller, standard Poseidon permutations which are consistent across both libraries (`poseidon-lite` supports up to arity 6 natively).

Instead of `hash_7`, we implemented:
```rust
// logical hash_7(a,b,c,d,e,f,g)
h1 = hash_4(a, b, c, d);
h2 = hash_3(e, f, g);
msg = hash_2(h1, h2);
```

This was applied to:
1.  **Noir (`src/main.nr`)**: Replacing `bn254::hash_7`.
2.  **TypeScript (`packages/crypto/src/poseidon.ts`)**: Reimplementing `poseidonHash7`.

### Verification Status
After this fix, the challenges `e` matched perfectly:
- JS `e`: `0x04229d52...`
- Noir `e`: `0x04229d52...`

And the full flow succeeded:
`nbt verify x402_zk_session` -> **SUCCESS**
